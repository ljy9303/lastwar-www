"use client"

import type React from "react"

import { useState, useEffect, useCallback, useMemo } from "react"
import { useSearchParams, useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Input } from "@/components/ui/input"
import { Search, ArrowLeft, FileDown, Save, Filter, ArrowUp, ArrowDown, Trophy } from "lucide-react"
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { toast } from "@/components/ui/use-toast"
import Link from "next/link"
import { getDesertById } from "../actions/event-actions"
import {
  getDesertResults,
  saveDesertResultSummary,
  getDesertResultSummary,
  type DesertRosterResult,
  type DesertResultSummary,
} from "../actions/desert-result-actions"
import { fetchFromAPI } from "@/lib/api-service"

// ÏÑ±Í≥º ÌÉúÍ∑∏ ÏòµÏÖò
const PERFORMANCE_TAGS = [
  { value: "total", label: "Ï¢ÖÌï©Ï†êÏàò", icon: "üèÜ", color: "bg-purple-500" },
  { value: "command", label: "Í±∞Ï†êÏ†êÏàò", icon: "üè∞", color: "bg-green-500" },
  { value: "gather", label: "ÏûêÏõêÏàòÏßë", icon: "üíé", color: "bg-blue-500" },
  { value: "break", label: "Íµ¨Ï°∞Î¨ºÌååÍ¥¥", icon: "üî®", color: "bg-orange-500" },
  { value: "kill", label: "Ï†ÅÏ≤òÏπò", icon: "‚öîÔ∏è", color: "bg-red-500" },
]

// ResultRow Ïª¥Ìè¨ÎÑåÌä∏Î•º Î∂ÑÎ¶¨ÌïòÏó¨ ÏÑ±Îä• ÏµúÏ†ÅÌôî
function ResultRow({
  result,
  trackChange,
  getTeamName,
  getPerformanceBadge,
  mvpSelections,
  setMvpSelections,
  results,
}: {
  result: DesertRosterResult
  trackChange: (result: DesertRosterResult) => void
  getTeamName: (team: string) => string
  getPerformanceBadge: (tag: string) => React.ReactNode
  mvpSelections: Record<string, number | null>
  setMvpSelections: React.Dispatch<React.SetStateAction<Record<string, number | null>>>
  results: DesertRosterResult[]
}) {
  const [localResult, setLocalResult] = useState(result)
  const [isEdited, setIsEdited] = useState(false)

  // Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÎßàÏö¥Ìä∏Îê† ÎïåÏôÄ resultÍ∞Ä Î≥ÄÍ≤ΩÎê† Îïå Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  useEffect(() => {
    setLocalResult(result)
    setIsEdited(false)
  }, [result])

  // Î°úÏª¨ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
  const handleChange = useCallback(
    (field: keyof DesertRosterResult, value: any) => {
      setLocalResult((prev) => {
        const updated = { ...prev, [field]: value }
        const isChanged = JSON.stringify(updated) !== JSON.stringify(result)
        setIsEdited(isChanged)

        // Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏûàÏúºÎ©¥ Ï∂îÏ†Å
        if (isChanged) {
          trackChange(updated)
        }

        return updated
      })
    },
    [result, trackChange],
  )

  // MVP ÏÑ†ÌÉù ÎìúÎ°≠Îã§Ïö¥
  const mvpOptions = useMemo(() => {
    return PERFORMANCE_TAGS.map((tag) => {
      // Ïù¥ÎØ∏ Îã§Î•∏ ÏÇ¨Ïö©ÏûêÍ∞Ä Ìï¥Îãπ ÌÉúÍ∑∏Ïùò MVPÎ°ú ÏÑ†ÌÉùÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const currentMvp = mvpSelections[tag.value]
      const isAlreadySelected = currentMvp !== null && currentMvp !== result.userSeq
      // ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÍ∞Ä Ïù¥ÎØ∏ Îã§Î•∏ ÌÉúÍ∑∏Ïùò MVPÎ°ú ÏÑ†ÌÉùÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const hasOtherTag = result.tag && result.tag !== "none" && result.tag !== tag.value

      return {
        ...tag,
        disabled: isAlreadySelected || hasOtherTag,
      }
    })
  }, [mvpSelections, result])

  // MVP ÏÑ†ÌÉù Ï≤òÎ¶¨
  const handleMvpSelect = useCallback(
    (tagValue: string) => {
      // Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú ÌÉúÍ∑∏Ïù∏ Í≤ΩÏö∞ Ìï¥Ï†ú
      if (result.tag === tagValue) {
        const updatedResult = { ...result, tag: "none" }
        trackChange(updatedResult)
        // MVP ÏÑ†ÌÉù ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        setMvpSelections((prev) => ({
          ...prev,
          [tagValue]: null,
        }))
      } else {
        // ÏÉàÎ°úÏö¥ ÌÉúÍ∑∏ ÏÑ†ÌÉù
        // Ïù¥Ï†ÑÏóê Îã§Î•∏ ÌÉúÍ∑∏Í∞Ä ÏûàÏóàÎã§Î©¥ Ï†úÍ±∞
        if (result.tag && result.tag !== "none") {
          setMvpSelections((prev) => ({
            ...prev,
            [result.tag]: null,
          }))
        }

        // Ïù¥Ï†ÑÏóê Îã§Î•∏ ÏÇ¨Ïö©ÏûêÍ∞Ä Ìï¥Îãπ ÌÉúÍ∑∏Ïùò MVPÏòÄÎã§Î©¥ Ìï¥Ï†ú
        const prevUserSeq = mvpSelections[tagValue]
        if (prevUserSeq !== null && prevUserSeq !== result.userSeq) {
          const prevUser = results.find((r) => r.userSeq === prevUserSeq)
          if (prevUser) {
            const updatedPrevUser = { ...prevUser, tag: "none" }
            trackChange(updatedPrevUser)
          }
        }

        // ÏÉà ÌÉúÍ∑∏ ÏÑ§Ï†ï
        const updatedResult = { ...result, tag: tagValue }
        trackChange(updatedResult)

        // MVP ÏÑ†ÌÉù ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        setMvpSelections((prev) => ({
          ...prev,
          [tagValue]: result.userSeq,
        }))
      }
    },
    [result, trackChange, mvpSelections, results, setMvpSelections],
  )

  const performanceBadge = useMemo(() => {
    return localResult.tag && localResult.tag !== "none" ? getPerformanceBadge(localResult.tag) : null
  }, [localResult.tag, getPerformanceBadge])

  return (
    <TableRow>
      <TableCell>
        <Button
          variant={localResult.isPlayed ? "default" : "outline"}
          size="sm"
          className={`w-20 h-8 transition-all ${
            localResult.isPlayed ? "bg-green-500 hover:bg-green-600" : "text-gray-500 hover:text-gray-700"
          }`}
          onClick={() => handleChange("isPlayed", !localResult.isPlayed)}
        >
          {localResult.isPlayed ? "Ï∞∏ÏÑù" : "Î∂àÏ∞∏"}
        </Button>
      </TableCell>
      <TableCell>
        <div>
          <div>{localResult.name}</div>
          <div className="sm:hidden text-xs text-muted-foreground">{getTeamName(localResult.desertType)}</div>
        </div>
      </TableCell>
      <TableCell className="hidden sm:table-cell">{getTeamName(localResult.desertType)}</TableCell>
      <TableCell className="hidden sm:table-cell">
        {performanceBadge || (
          <div className="flex flex-wrap gap-1">
            {mvpOptions.map((tag) => (
              <Button
                key={tag.value}
                variant="outline"
                size="sm"
                className={`px-2 py-1 h-auto text-xs ${tag.disabled ? "opacity-50 cursor-not-allowed" : ""}`}
                onClick={() => !tag.disabled && handleMvpSelect(tag.value)}
                disabled={tag.disabled}
              >
                <span className="mr-1">{tag.icon}</span>
                <span>{tag.label}</span>
              </Button>
            ))}
          </div>
        )}
      </TableCell>
      <TableCell className="hidden md:table-cell">
        <Input
          placeholder="ÎπÑÍ≥†"
          value={localResult.description || ""}
          onChange={(e) => handleChange("description", e.target.value)}
        />
      </TableCell>
      <TableCell>
        {isEdited && (
          <Badge variant="outline" className="bg-blue-50">
            Î≥ÄÍ≤ΩÎê®
          </Badge>
        )}
      </TableCell>
    </TableRow>
  )
}

// ÌåÄ ÌååÎùºÎØ∏ÌÑ∞Î•º Ìè¨Ìï®Ìïú Í≤∞Í≥º Î°úÎìú Ìï®Ïàò
const loadDesertResults = async (desertSeq: number, team?: string) => {
  try {
    // Í∏∞Î≥∏ API Ìò∏Ï∂ú
    const results = await getDesertResults(desertSeq)

    // ÌåÄ ÌååÎùºÎØ∏ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ Ìï¥Îãπ ÌåÄÎßå ÌïÑÌÑ∞ÎßÅ
    if (team) {
      return results.filter((result) => result.desertType.toUpperCase().startsWith(team))
    }

    return results
  } catch (error) {
    console.error("Í≤∞Í≥º Î°úÎìú Ïã§Ìå®:", error)
    throw error
  }
}

export default function DesertResultsPage() {
  const searchParams = useSearchParams()
  const router = useRouter()
  const eventId = searchParams.get("eventId")
  const desertSeq = eventId ? Number.parseInt(eventId) : null

  const [results, setResults] = useState<DesertRosterResult[]>([])
  const [filteredResults, setFilteredResults] = useState<DesertRosterResult[]>([])
  const [searchTerm, setSearchTerm] = useState("")
  const [selectedEvent, setSelectedEvent] = useState<any>(null)
  const [eventSummary, setEventSummary] = useState<DesertResultSummary | null>(null)
  const [activeTab, setActiveTab] = useState("a")
  const [teamSortDirection, setTeamSortDirection] = useState<"asc" | "desc" | null>(null)
  const [pendingChanges, setPendingChanges] = useState<Record<number, DesertRosterResult>>({})
  const [isLoading, setIsLoading] = useState(true)
  const [isSaving, setIsSaving] = useState(false)
  const [showOnlyParticipated, setShowOnlyParticipated] = useState(false)
  const [mvpSelections, setMvpSelections] = useState<Record<string, number | null>>({
    total: null,
    command: null,
    gather: null,
    break: null,
    kill: null,
  })
  const [teamCounts, setTeamCounts] = useState<Record<string, number>>({
    A: 0,
    B: 0,
  })

  // Ïù¥Î≤§Ìä∏ Î∞è Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ Î°úÎìú
  useEffect(() => {
    async function loadData() {
      if (!desertSeq) {
        setIsLoading(false)
        return
      }

      try {
        setIsLoading(true)
        // ÏÇ¨ÎßâÏ†Ñ Ï†ïÎ≥¥ Î°úÎìú
        try {
          const eventData = await getDesertById(desertSeq)
          setSelectedEvent(eventData)
        } catch (error) {
          console.error("ÏÇ¨ÎßâÏ†Ñ Ï†ïÎ≥¥ Î°úÎìú Ïã§Ìå®:", error)
          // Í∏∞Î≥∏ Ïù¥Î≤§Ìä∏ Ï†ïÎ≥¥ ÏÑ§Ï†ï
          setSelectedEvent({ title: `ÏÇ¨ÎßâÏ†Ñ #${desertSeq}` })
        }

        // ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥º Î°úÎìú - Ï¥àÍ∏∞ Î°úÎìúÎäî ÌåÄ ÌååÎùºÎØ∏ÌÑ∞ ÏóÜÏù¥
        try {
          const resultsData = await loadDesertResults(desertSeq)
          setResults(resultsData)
          setFilteredResults(resultsData)

          // ÌåÄÎ≥Ñ Ïù∏Ïõê Ïàò Í≥ÑÏÇ∞
          const counts = {
            A: 0,
            B: 0,
          }

          resultsData.forEach((result) => {
            const teamType = result.desertType.toUpperCase()
            if (teamType.startsWith("A")) {
              counts.A++
            } else if (teamType.startsWith("B")) {
              counts.B++
            }
          })

          setTeamCounts(counts)

          // Í∏∞Ï°¥ MVP ÏÑ§Ï†ï Î°úÎìú
          const mvpInit: Record<string, number | null> = {
            total: null,
            command: null,
            gather: null,
            break: null,
            kill: null,
          }

          resultsData.forEach((result) => {
            if (result.tag && result.tag !== "none" && mvpInit.hasOwnProperty(result.tag)) {
              mvpInit[result.tag] = result.userSeq
            }
          })

          setMvpSelections(mvpInit)
        } catch (error) {
          console.error("ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥º Î°úÎìú Ïã§Ìå®:", error)
          toast({
            title: "Í≤∞Í≥º Î°úÎìú Ïã§Ìå®",
            description: "ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥ºÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
            variant: "destructive",
          })
          // Îπà Í≤∞Í≥º Î∞∞Ïó¥ ÏÑ§Ï†ï
          setResults([])
          setFilteredResults([])
        }

        // ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥º ÏöîÏïΩ Î°úÎìú
        try {
          const summaryData = await getDesertResultSummary(desertSeq)
          setEventSummary(summaryData)
        } catch (error) {
          console.error("ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥º ÏöîÏïΩ Î°úÎìú Ïã§Ìå®:", error)
          // Í∏∞Î≥∏ ÏöîÏïΩ Ï†ïÎ≥¥ ÏÑ§Ï†ï
          setEventSummary({
            desertSeq,
            winnerType: "",
            description: "",
          })
        }
      } catch (error) {
        console.error("Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:", error)
        toast({
          title: "Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®",
          description: "ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥ºÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
          variant: "destructive",
        })
      } finally {
        setIsLoading(false)
      }
    }

    loadData()
  }, [desertSeq])

  // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú URL ÌååÎùºÎØ∏ÌÑ∞Ïóê Îî∞Îùº Ï¥àÍ∏∞ ÌÉ≠ ÏÑ§Ï†ï
  useEffect(() => {
    const teamParam = searchParams.get("team")
    if (teamParam) {
      if (teamParam.toUpperCase() === "A") {
        setActiveTab("a")
      } else if (teamParam.toUpperCase() === "B") {
        setActiveTab("b")
      }
    }
  }, [searchParams])

  // ÌÉ≠ Î≥ÄÍ≤Ω Ïãú URL ÌååÎùºÎØ∏ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
  const handleTabChange = async (value: string) => {
    setActiveTab(value)
    setIsLoading(true)

    try {
      // ÌåÄ ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï (a -> A, b -> B)
      const teamParam = value.toUpperCase()

      // Ìï¥Îãπ ÌåÄ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
      const resultsData = await loadDesertResults(desertSeq, teamParam)

      setResults(resultsData)
      setFilteredResults(resultsData)

      // MVP ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
      const mvpInit: Record<string, number | null> = {
        total: null,
        command: null,
        gather: null,
        break: null,
        kill: null,
      }

      resultsData.forEach((result) => {
        if (result.tag && result.tag !== "none" && mvpInit.hasOwnProperty(result.tag)) {
          mvpInit[result.tag] = result.userSeq
        }
      })

      setMvpSelections(mvpInit)

      toast({
        title: `${teamParam}ÌåÄ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å`,
        description: `${resultsData.length}Î™ÖÏùò Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§.`,
      })
    } catch (error) {
      console.error(`${value.toUpperCase()}ÌåÄ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:`, error)
      toast({
        title: "Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®",
        description: `${value.toUpperCase()}ÌåÄ Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.`,
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }

  // Í≤ÄÏÉâÏñ¥ÏôÄ ÌïÑÌÑ∞Ïóê Îî∞Îùº Í≤∞Í≥º ÌïÑÌÑ∞ÎßÅ
  useEffect(() => {
    if (!results.length) {
      setFilteredResults([])
      return
    }

    let filtered = [...results]

    // Í≤ÄÏÉâÏñ¥Î°ú ÌïÑÌÑ∞ÎßÅ
    if (searchTerm) {
      filtered = filtered.filter((result) => result.name.toLowerCase().includes(searchTerm.toLowerCase()))
    }

    // ÌÉ≠Ïóê Îî∞Îùº ÌïÑÌÑ∞ÎßÅ (ÎåÄÏÜåÎ¨∏Ïûê Íµ¨Î∂Ñ ÏóÜÏù¥)
    if (activeTab === "a") {
      filtered = filtered.filter((result) => result.desertType.toUpperCase().startsWith("A"))
    } else if (activeTab === "b") {
      filtered = filtered.filter((result) => result.desertType.toUpperCase().startsWith("B"))
    }

    // Ï∞∏Ïó¨ÏûêÎßå ÌëúÏãú ÏòµÏÖò
    if (showOnlyParticipated) {
      filtered = filtered.filter((result) => result.isPlayed)
    }

    // ÌåÄÏúºÎ°ú Ï†ïÎ†¨
    if (teamSortDirection) {
      filtered.sort((a, b) => {
        const teamA = a.desertType
        const teamB = b.desertType
        return teamSortDirection === "asc" ? teamA.localeCompare(teamB) : teamB.localeCompare(teamA)
      })
    }

    setFilteredResults(filtered)
  }, [results, searchTerm, activeTab, showOnlyParticipated, teamSortDirection])

  // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï∂îÏ†Å
  const trackChange = useCallback((result: DesertRosterResult) => {
    setPendingChanges((prev) => ({
      ...prev,
      [result.userSeq]: result,
    }))
  }, [])

  // MVP ÏÑ†ÌÉù Î≥ÄÍ≤Ω Ï≤òÎ¶¨
  const handleMvpChange = useCallback(
    (performanceTag: string, value: string) => {
      // ÏÑ†ÌÉù ÏïàÌï®Ïù∏ Í≤ΩÏö∞
      if (value === "") {
        setMvpSelections((prev) => ({
          ...prev,
          [performanceTag]: null,
        }))

        // Ïù¥Ï†ÑÏóê ÏÑ†ÌÉùÎêú ÏÇ¨Ïö©ÏûêÏùò ÌÉúÍ∑∏ Ï†úÍ±∞
        const prevUserSeq = mvpSelections[performanceTag]
        if (prevUserSeq !== null) {
          const prevUser = results.find((r) => r.userSeq === prevUserSeq)
          if (prevUser) {
            const updatedPrevUser = { ...prevUser, tag: "none" }
            trackChange(updatedPrevUser)
          }
        }
        return
      }

      // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ†ÌÉùÎêú Í≤ΩÏö∞ - Ïù¥ Î∂ÄÎ∂ÑÏùÄ Ïù¥Ï†ú ÌÖåÏù¥Î∏îÏóêÏÑú Ï≤òÎ¶¨Îê®
    },
    [mvpSelections, results, trackChange],
  )

  // MVP Ï†ÄÏû•
  const saveMvpSelections = useCallback(async () => {
    if (Object.keys(pendingChanges).length === 0) return

    try {
      setIsSaving(true)

      // ÏÉàÎ°úÏö¥ API ÌòïÏãùÏóê ÎßûÍ≤å Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
      const requestData = {
        desertSeq,
        rosters: Object.values(pendingChanges).map((result) => ({
          userSeq: result.userSeq,
          isPlayed: result.isPlayed,
          tag: result.tag || "none",
          description: result.description || "",
        })),
      }

      // ÏÉà API ÏóîÎìúÌè¨Ïù∏Ìä∏Î°ú Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ìïú Î≤àÏóê Ï†ÄÏû•
      await fetchFromAPI(`/desert/roster/final/save`, {
        method: "POST",
        body: JSON.stringify(requestData),
      })

      // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      setResults((prev) => prev.map((item) => (pendingChanges[item.userSeq] ? pendingChanges[item.userSeq] : item)))

      // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï¥àÍ∏∞Ìôî
      setPendingChanges({})

      toast({
        title: "MVP Ï†ÄÏû• ÏôÑÎ£å",
        description: `${Object.keys(pendingChanges).length}Í∞úÏùò ÏÑ±Í≥ºÍ∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`,
      })
    } catch (error) {
      console.error("MVP ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:", error)
      toast({
        title: "Ï†ÄÏû• Ïã§Ìå®",
        description: "ÏÑ±Í≥ºÎ•º Ï†ÄÏû•ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }, [pendingChanges, desertSeq])

  // Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï†ÄÏû•
  const saveAllChanges = useCallback(async () => {
    if (Object.keys(pendingChanges).length === 0) return

    try {
      setIsSaving(true)

      // ÏÉàÎ°úÏö¥ API ÌòïÏãùÏóê ÎßûÍ≤å Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
      const requestData = {
        desertSeq,
        rosters: Object.values(pendingChanges).map((result) => ({
          userSeq: result.userSeq,
          isPlayed: result.isPlayed,
          tag: result.tag || "none",
          description: result.description || "",
        })),
      }

      // ÏÉà API ÏóîÎìúÌè¨Ïù∏Ìä∏Î°ú Î™®Îì† Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ìïú Î≤àÏóê Ï†ÄÏû•
      await fetchFromAPI(`/desert/roster/final/save`, {
        method: "POST",
        body: JSON.stringify(requestData),
      })

      // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      setResults((prev) => prev.map((item) => (pendingChanges[item.userSeq] ? pendingChanges[item.userSeq] : item)))

      // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Ï¥àÍ∏∞Ìôî
      setPendingChanges({})

      toast({
        title: "Ï†ÄÏû• ÏôÑÎ£å",
        description: `${Object.keys(pendingChanges).length}Í∞úÏùò Í≤∞Í≥ºÍ∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`,
      })
    } catch (error) {
      console.error("Í≤∞Í≥º ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:", error)
      toast({
        title: "Ï†ÄÏû• Ïã§Ìå®",
        description: "Í≤∞Í≥ºÎ•º Ï†ÄÏû•ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }, [pendingChanges, desertSeq])

  // Í≤∞Í≥º ÏöîÏïΩ Ï†ÄÏû•
  const saveSummary = useCallback(async () => {
    if (!eventSummary || !desertSeq) return

    try {
      setIsSaving(true)
      const summary = {
        ...eventSummary,
        desertSeq,
      }

      // API ÏóîÎìúÌè¨Ïù∏Ìä∏Í∞Ä ÏïÑÏßÅ Íµ¨ÌòÑÎêòÏßÄ ÏïäÏïòÏùÑ Ïàò ÏûàÏúºÎØÄÎ°ú ÏûÑÏãú Ï≤òÎ¶¨
      try {
        await saveDesertResultSummary(summary)

        toast({
          title: "Ï†ÄÏû• ÏôÑÎ£å",
          description: "ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥º ÏöîÏïΩÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.",
        })
      } catch (error) {
        console.error("API ÏóîÎìúÌè¨Ïù∏Ìä∏ Ïò§Î•ò:", error)
        toast({
          title: "Ï†ÄÏû• ÏôÑÎ£å (ÌÖåÏä§Ìä∏ Î™®Îìú)",
          description: "APIÍ∞Ä ÏïÑÏßÅ Íµ¨ÌòÑÎêòÏßÄ ÏïäÏïÑ Î°úÏª¨ÏóêÎßå Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.",
        })
      }
    } catch (error) {
      console.error("Í≤∞Í≥º ÏöîÏïΩ Ï†ÄÏû• Ïã§Ìå®:", error)
      toast({
        title: "Ï†ÄÏû• Ïã§Ìå®",
        description: "Í≤∞Í≥º ÏöîÏïΩÏùÑ Ï†ÄÏû•ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        variant: "destructive",
      })
    } finally {
      setIsSaving(false)
    }
  }, [eventSummary, desertSeq])

  // ÌåÄ Ïù¥Î¶Ñ ÌëúÏãú
  const getTeamName = useCallback((team: string) => {
    switch (team) {
      case "A_TEAM":
        return "AÌåÄ"
      case "B_TEAM":
        return "BÌåÄ"
      case "A_RESERVE":
        return "AÌåÄ ÏòàÎπÑ"
      case "B_RESERVE":
        return "BÌåÄ ÏòàÎπÑ"
      case "UNASSIGNED":
        return "ÎØ∏Î∞∞Ï†ï"
      case "EXCLUDED":
        return "Ï†úÏô∏"
      default:
        return team
    }
  }, [])

  // ÏÑ±Í≥º Î∞∞ÏßÄ
  const getPerformanceBadge = useCallback((tag: string) => {
    switch (tag) {
      case "total":
        return <Badge className="bg-purple-500">üèÜ Ï¢ÖÌï©Ï†êÏàò</Badge>
      case "command":
        return <Badge className="bg-green-500">üè∞ Í±∞Ï†êÏ†êÏàò</Badge>
      case "gather":
        return <Badge className="bg-blue-500">üíé ÏûêÏõêÏàòÏßë</Badge>
      case "break":
        return <Badge className="bg-orange-500">üî® Íµ¨Ï°∞Î¨ºÌååÍ¥¥</Badge>
      case "kill":
        return <Badge className="bg-red-500">‚öîÔ∏è Ï†ÅÏ≤òÏπò</Badge>
      case "none":
        return <Badge variant="secondary">ÏóÜÏùå</Badge>
      default:
        return tag ? <Badge>{tag}</Badge> : null
    }
  }, [])

  // CSV ÎÇ¥Î≥¥ÎÇ¥Í∏∞
  const exportToCsv = useCallback(() => {
    if (!results.length) return

    const headers = ["ID", "ÎãâÎÑ§ÏûÑ", "ÌåÄ", "Ï∞∏Ïó¨ Ïó¨Î∂Ä", "ÏÑ±Í≥º", "ÎπÑÍ≥†"]
    const csvContent = [
      headers.join(","),
      ...results.map((result) => {
        const performanceLabel = PERFORMANCE_TAGS.find((t) => t.value === result.tag)?.label || result.tag || "ÏóÜÏùå"

        return [
          result.userSeq,
          result.name,
          getTeamName(result.desertType),
          result.isPlayed ? "O" : "X",
          performanceLabel,
          `"${result.description?.replace(/"/g, '""') || ""}"`, // ÏåçÎî∞Ïò¥Ìëú Ïù¥Ïä§ÏºÄÏù¥ÌîÑ
        ].join(",")
      }),
    ].join("\n")

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" })
    const url = URL.createObjectURL(blob)
    const link = document.createElement("a")
    link.setAttribute("href", url)
    link.setAttribute("download", `ÏÇ¨ÎßâÏ†ÑÍ≤∞Í≥º_${selectedEvent?.title || "Ï†ÑÏ≤¥"}.csv`)
    link.style.visibility = "hidden"
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  }, [results, selectedEvent, getTeamName])

  const isSaveAllChangesButtonDisabled = useMemo(
    () => Object.keys(pendingChanges).length === 0 || isSaving,
    [pendingChanges, isSaving],
  )

  const saveAllChangesButtonContent = isSaving ? "Ï†ÄÏû• Ï§ë..." : `Ï†ÄÏû• (${Object.keys(pendingChanges).length})`

  // showOnlyParticipated ÏÉÅÌÉúÎ•º Î®ºÏ†Ä Ï†ïÏùò
  const [isTooltipOpen, setIsTooltipOpen] = useState(false)

  if (!desertSeq) {
    return (
      <div className="container mx-auto p-4">
        <h1 className="text-3xl font-bold mb-6">ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥º</h1>
        <Card>
          <CardContent className="p-6">
            <p className="text-center">ÏÇ¨ÎßâÏ†ÑÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.</p>
            <Button asChild className="mt-4 mx-auto block">
              <Link href="/events">ÏÇ¨ÎßâÏ†Ñ Î™©Î°ùÏúºÎ°ú Ïù¥Îèô</Link>
            </Button>
          </CardContent>
        </Card>
      </div>
    )
  }

  // ÌåÄÎ≥Ñ Ï∞∏Ïó¨Ïûê Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞ - useMemoÎ°ú ÏµúÏ†ÅÌôî
  const teamParticipants = useMemo(() => {
    return results
      .filter((r) => r.desertType.startsWith(activeTab.toUpperCase()) && r.isPlayed)
      .sort((a, b) => a.name.localeCompare(b.name))
  }, [results, activeTab])

  // Ïù¥ÎØ∏ ÏÑ†ÌÉùÎêú ÏÑ±Í≥º ÌÉúÍ∑∏ ÌôïÏù∏
  const usedTags = useMemo(() => {
    const tags: Record<string, boolean> = {}
    Object.entries(mvpSelections).forEach(([tag, userSeq]) => {
      if (userSeq !== null) {
        tags[tag] = true
      }
    })
    return tags
  }, [mvpSelections])

  // Ïù¥ÎØ∏ MVPÎ°ú ÏÑ†ÌÉùÎêú ÏÇ¨Ïö©Ïûê ÌôïÏù∏
  const usedUsers = useMemo(() => {
    const users: Record<number, boolean> = {}
    Object.values(mvpSelections).forEach((userSeq) => {
      if (userSeq !== null) {
        users[userSeq] = true
      }
    })
    return users
  }, [mvpSelections])

  return (
    <div className="container mx-auto">
      <div className="flex items-center gap-2 mb-6">
        <Button variant="ghost" size="icon" asChild>
          <Link href={`/events/${desertSeq}`}>
            <ArrowLeft className="h-5 w-5" />
          </Link>
        </Button>
        <h1 className="text-3xl font-bold">ÏÇ¨ÎßâÏ†Ñ Í≤∞Í≥º {selectedEvent && `- ${selectedEvent.title}`}</h1>
      </div>

      <div className="grid grid-cols-1 gap-6 mb-6">
        <Card>
          <CardHeader>
            <div className="flex justify-between items-center">
              <div>
                <CardTitle>Ï∞∏Ïó¨Ïûê ÏÑ±Í≥º Í¥ÄÎ¶¨</CardTitle>
                <CardDescription>ÏÇ¨ÎßâÏ†Ñ Ï∞∏Ïó¨ÏûêÎì§Ïùò ÏÑ±Í≥ºÏôÄ Ï∞∏Ïó¨ Ïó¨Î∂ÄÎ•º Í¥ÄÎ¶¨Ìï©ÎãàÎã§.</CardDescription>
              </div>
              <div className="flex gap-2">
                <Button
                  variant="default"
                  onClick={saveAllChanges}
                  disabled={isSaveAllChangesButtonDisabled}
                  className="mr-2"
                >
                  <Save className="mr-2 h-4 w-4" />
                  {saveAllChangesButtonContent}
                </Button>
                <TooltipProvider>
                  <Tooltip open={isTooltipOpen} onOpenChange={setIsTooltipOpen}>
                    <TooltipTrigger asChild>
                      <Button
                        variant="outline"
                        size="icon"
                        onClick={() => setShowOnlyParticipated(!showOnlyParticipated)}
                      >
                        <Filter className="h-4 w-4" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>{showOnlyParticipated ? "Î™®Îì† Ïù∏Ïõê ÌëúÏãú" : "Ï∞∏Ïó¨ÏûêÎßå ÌëúÏãú"}</TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                <Button variant="outline" onClick={exportToCsv} disabled={!results.length}>
                  <FileDown className="mr-2 h-4 w-4" />
                  CSV ÎÇ¥Î≥¥ÎÇ¥Í∏∞
                </Button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <Tabs value={activeTab} onValueChange={handleTabChange} className="mb-4">
              <TabsList>
                <TabsTrigger value="a">AÌåÄ ({teamCounts.A})</TabsTrigger>
                <TabsTrigger value="b">BÌåÄ ({teamCounts.B})</TabsTrigger>
              </TabsList>
            </Tabs>

            {/* MVP ÏòÅÏó≠ */}
            <Card className="mb-6 border-2 border-dashed">
              <CardHeader className="pb-2">
                <div className="flex items-center justify-between">
                  <CardTitle className="flex items-center">
                    <Trophy className="mr-2 h-5 w-5" />
                    MVP ÏÑ†Ï†ï
                  </CardTitle>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={saveMvpSelections}
                    disabled={Object.keys(pendingChanges).length === 0 || isSaving}
                  >
                    {isSaving ? "Ï†ÄÏû• Ï§ë..." : "MVP Ï†ÄÏû•"}
                  </Button>
                </div>
                <CardDescription>
                  Í∞Å ÏÑ±Í≥º Ìï≠Î™©Î≥ÑÎ°ú MVPÎ•º ÏÑ†Ï†ïÌï©ÎãàÎã§. Ìïú Î™ÖÏùò Í∏∏ÎìúÏõêÏù¥ Ïó¨Îü¨ Ìï≠Î™©ÏùÑ Î∞õÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.
                </CardDescription>
              </CardHeader>
              <CardContent>
                <div className="grid grid-cols-1 md:grid-cols-5 gap-3">
                  {PERFORMANCE_TAGS.map((tag) => {
                    const selectedUserSeq = mvpSelections[tag.value]
                    const selectedUser =
                      selectedUserSeq !== null ? results.find((r) => r.userSeq === selectedUserSeq) : null

                    return (
                      <div key={tag.value} className="border rounded-md p-3">
                        <div className={`flex items-center justify-center p-2 rounded-md mb-2 ${tag.color} text-white`}>
                          <span className="mr-1">{tag.icon}</span>
                          <span className="font-medium">{tag.label}</span>
                        </div>
                        {selectedUser ? (
                          <div className="flex items-center justify-between p-2 border rounded-md">
                            <div className="flex items-center">
                              <div
                                className="w-4 h-4 mr-2 rounded-full"
                                style={{ backgroundColor: tag.color.replace("bg-", "") }}
                              ></div>
                              <span>{selectedUser.name}</span>
                            </div>
                            <Button
                              variant="ghost"
                              size="sm"
                              className="h-6 w-6 p-0"
                              onClick={() => handleMvpChange(tag.value, "")}
                            >
                              <span className="sr-only">Ï†úÍ±∞</span>
                              <svg
                                xmlns="http://www.w3.org/2000/svg"
                                width="16"
                                height="16"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                strokeWidth="2"
                                strokeLinecap="round"
                                strokeLinejoin="round"
                              >
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                              </svg>
                            </Button>
                          </div>
                        ) : (
                          <div className="text-center text-sm text-muted-foreground p-2">
                            ÏïÑÎûò Î™©Î°ùÏóêÏÑú Ïó∞ÎßπÏõêÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî
                          </div>
                        )}
                      </div>
                    )
                  })}
                </div>
              </CardContent>
            </Card>

            <div className="relative mb-4">
              <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="ÎãâÎÑ§ÏûÑÏúºÎ°ú Í≤ÄÏÉâ..."
                className="pl-8"
                value={searchTerm}
                onChange={(e) => {
                  setSearchTerm(e.target.value)

                  // MVP ÏÑ†ÌÉù ÎìúÎ°≠Îã§Ïö¥Ïùò Î™®Îì† Í≤ÄÏÉâ ÌïÑÎìúÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
                  const searchInputs = document.querySelectorAll(".mvp-search-input") as NodeListOf<HTMLInputElement>
                  searchInputs.forEach((input) => {
                    input.value = e.target.value

                    // Í∞Å ÎìúÎ°≠Îã§Ïö¥ ÎÇ¥ Ìï≠Î™© ÌïÑÌÑ∞ÎßÅ
                    const tag = input.getAttribute("data-search-tag")
                    if (tag) {
                      const searchTerm = e.target.value.toLowerCase()
                      const items = document.querySelectorAll(`[data-tag="${tag}"] [data-user-item]`)
                      items.forEach((item) => {
                        const userName = item.getAttribute("data-user-name")?.toLowerCase() || ""
                        if (userName.includes(searchTerm)) {
                          ;(item as HTMLElement).style.display = ""
                        } else {
                          ;(item as HTMLElement).style.display = "none"
                        }
                      })
                    }
                  })
                }}
              />
            </div>

            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-[50px]">Ï∞∏ÏÑùÏó¨Î∂Ä</TableHead>
                    <TableHead>ÎãâÎÑ§ÏûÑ</TableHead>
                    <TableHead
                      className="hidden sm:table-cell cursor-pointer select-none"
                      onClick={() => {
                        setTeamSortDirection((prev) => (prev === null ? "asc" : prev === "asc" ? "desc" : null))
                      }}
                    >
                      <div className="flex items-center">
                        ÌåÄ{teamSortDirection === "asc" && <ArrowUp className="ml-1 h-4 w-4" />}
                        {teamSortDirection === "desc" && <ArrowDown className="ml-1 h-4 w-4" />}
                      </div>
                    </TableHead>
                    <TableHead className="hidden sm:table-cell">ÏÑ±Í≥º</TableHead>
                    <TableHead className="hidden md:table-cell">ÎπÑÍ≥†</TableHead>
                    <TableHead className="w-[80px]">ÏÉÅÌÉú</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {isLoading ? (
                    <TableRow>
                      <TableCell colSpan={6} className="text-center py-4">
                        Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...
                      </TableCell>
                    </TableRow>
                  ) : filteredResults.length > 0 ? (
                    filteredResults.map((result) => (
                      <ResultRow
                        key={result.userSeq}
                        result={result}
                        trackChange={trackChange}
                        getTeamName={getTeamName}
                        getPerformanceBadge={getPerformanceBadge}
                        mvpSelections={mvpSelections}
                        setMvpSelections={setMvpSelections}
                        results={results}
                      />
                    ))
                  ) : (
                    <TableRow>
                      <TableCell colSpan={6} className="text-center py-4">
                        {results.length > 0 ? (
                          <>
                            <p>Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.</p>
                            <p className="text-sm text-muted-foreground mt-1">
                              {activeTab === "b" && teamCounts.B === 0
                                ? "BÌåÄÏóê Î∞∞Ï†ïÎêú Ïù∏ÏõêÏù¥ ÏóÜÏäµÎãàÎã§."
                                : "ÌïÑÌÑ∞ Ï°∞Í±¥ÏùÑ Î≥ÄÍ≤ΩÌï¥Î≥¥ÏÑ∏Ïöî."}
                            </p>
                          </>
                        ) : (
                          "Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§."
                        )}
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
